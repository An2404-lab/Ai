<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>IFS Attractor với Point Cloud Collision Detection</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: #fff;
      display: flex;
      justify-content: center;
      margin: 0;
      padding: 20px;
      gap: 20px;
    }
    h2 {
      margin-bottom: 15px;
      font-size: 1.5em;
    }
    #left-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #controls {
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    input[type="range"] {
      width: 300px;
      accent-color: #4caf50;
    }
    input[type="number"] {
      width: 80px;
      padding: 5px;
      background: #333;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
    }
    canvas {
      border: 1px solid #fff;
      background: #000;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
    }
    #right-panel {
      width: 400px;
      max-height: 600px;
      overflow-y: auto;
      background: #222;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
    }
    #right-panel h3 {
      margin-top: 0;
      font-size: 1.2em;
    }
    #right-panel p {
      margin: 5px 0;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div id="left-panel">
    <h2>IFS Attractor: f₁ (xanh lá), f₂ (đỏ)</h2>
    <div id="controls">
      <label for="kInput">k: </label>
      <input type="number" id="kInput" value="0.5" step="0.01" min="0" max="1">
      <input type="range" id="kSlider" min="0" max="1" step="0.01" value="0.5">
    </div>
    <canvas id="canvas" width="600" height="600"></canvas>
  </div>
  <div id="right-panel">
    <h3>Các bước Point Cloud Collision Detection</h3>
    <div id="algorithm-steps"></div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const kInput = document.getElementById("kInput");
    const kSlider = document.getElementById("kSlider");
    const stepsDiv = document.getElementById("algorithm-steps");

    let points = [[0, 0]];
    const maxPoints = 10000;

    kInput.addEventListener("input", () => {
      let value = parseFloat(kInput.value);
      if (!isNaN(value) && value >= 0 && value <= 1) {
        kSlider.value = value;
        points = [[0, 0]];
        draw();
      }
    });

    kSlider.addEventListener("input", () => {
      kInput.value = parseFloat(kSlider.value).toFixed(2);
      points = [[0, 0]];
      draw();
    });

    function transform(x, y, k, which) {
      if (which === 1) {
        return [0.5 * x, 0.5 * y + k]; // f1(x, y) = (0.5x, 0.5y + k)
      } else {
        return [0.5 * x + 1, 0.5 * y + 1 - k]; // f2(x, y) = (0.5x + 1, 0.5y + 1 - k)
      }
    }

    function toCanvas(px, py, minX, maxX, minY, maxY) {
      const width = canvas.width;
      const height = canvas.height;
      const xRange = maxX - minX || 1;
      const yRange = maxY - minY || 1;
      return [
        ((px - minX) / xRange) * width,
        ((maxY - py) / yRange) * height
      ];
    }

    function pointCloudCollisionDetection(greenPoints, redPoints) {
      // Bước 1: Định nghĩa bề mặt ngầm và tính giới hạn
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      greenPoints.forEach(([x, y]) => {
        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
      });
      redPoints.forEach(([x, y]) => {
        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
      });
      const scale = Math.max(maxX - minX, maxY - minY) || 1;
      const r_epsilon = 0.1 * scale;
      const d_epsilon = 0.005 * scale; // Giảm d_epsilon để nhạy hơn với touching

      let step1 = `Bước 1: Định nghĩa bề mặt ngầm\n`;
      step1 += `  - Giới hạn: minX = ${minX.toFixed(2)}, maxX = ${maxX.toFixed(2)}, minY = ${minY.toFixed(2)}, maxY = ${maxY.toFixed(2)}\n`;
      step1 += `  - r_ε = ${r_epsilon.toFixed(4)}, d_ε = ${d_epsilon.toFixed(4)}`;

      // Bước 2: Xây dựng cấu trúc phân cấp (quadtree đơn giản)
      function buildQuadTree(points, depth = 0) {
        if (points.length < 10 || depth > 3) return { points, bounds: { minX, maxX, minY, maxY } };
        const midX = (minX + maxX) / 2;
        const midY = (minY + maxY) / 2;
        const quadrants = [[], [], [], []];
        points.forEach(p => {
          const [x, y] = p;
          if (x < midX && y < midY) quadrants[0].push(p);
          else if (x >= midX && y < midY) quadrants[1].push(p);
          else if (x < midX && y >= midY) quadrants[2].push(p);
          else quadrants[3].push(p);
        });
        return quadrants.map((q, i) => ({
          points: q,
          bounds: {
            minX: i % 2 === 0 ? minX : midX,
            maxX: i % 2 === 0 ? midX : maxX,
            minY: i < 2 ? minY : midY,
            maxY: i < 2 ? midY : maxY
          }
        })).filter(q => q.points.length > 0);
      }
      const greenTree = buildQuadTree(greenPoints);
      const redTree = buildQuadTree(redPoints);
      let step2 = `Bước 2: Xây dựng cấu trúc phân cấp\n`;
      step2 += `  - Số vùng xanh: ${Array.isArray(greenTree) ? greenTree.length : 1}\n`;
      step2 += `  - Số vùng đỏ: ${Array.isArray(redTree) ? redTree.length : 1}`;

      // Bước 3: Duyệt phân cấp đồng thời
      let pairs = [];
      const greenNodes = Array.isArray(greenTree) ? greenTree : [greenTree];
      const redNodes = Array.isArray(redTree) ? redTree : [redTree];
      greenNodes.forEach(g => redNodes.forEach(r => {
        const dist = Math.max(
          Math.max(0, g.bounds.minX - r.bounds.maxX),
          Math.max(0, r.bounds.minX - g.bounds.maxX),
          Math.max(0, g.bounds.minY - r.bounds.maxY),
          Math.max(0, r.bounds.minY - g.bounds.maxY)
        );
        if (dist <= d_epsilon * 2) pairs.push([g, r]); // Nới lỏng tiêu chí để phát hiện touching
      }));
      let step3 = `Bước 3: Duyệt phân cấp\n`;
      step3 += `  - Số cặp vùng tiềm năng: ${pairs.length}`;

      // Bước 4: Kiểm tra va chạm tại lá
      let minDist = Infinity;
      let overlapCount = 0;
      pairs.forEach(([g, r]) => {
        g.points.forEach(p1 => {
          r.points.forEach(p2 => {
            const dist = Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2);
            minDist = Math.min(minDist, dist);
            if (dist < d_epsilon) overlapCount++;
          });
        });
      });
      let step4 = `Bước 4: Kiểm tra va chạm\n`;
      step4 += `  - Khoảng cách nhỏ nhất d_AB = ${minDist.toFixed(4)}\n`;
      step4 += `  - Số điểm chồng chéo: ${overlapCount}`;

      // Bước 5: Phân loại trạng thái
      let status = "Disconnected";
      if (overlapCount > 10) status = "Overlap"; // Nhiều điểm gần nhau
      else if (minDist <= d_epsilon * 2) status = "Touching"; // Gần nhưng không đủ chồng chéo
      let step5 = `Bước 5: Phân loại trạng thái\n`;
      step5 += `  - Trạng thái: ${status}`;

      return [step1, step2, step3, step4, step5, status];
    }

    function draw() {
      const k = parseFloat(kInput.value);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      while (points.length < maxPoints) {
        let [x, y] = points[points.length - 1];
        let which = Math.random() < 0.5 ? 1 : 2;
        points.push(transform(x, y, k, which));
      }

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (let i = 100; i < points.length; i++) {
        const [x, y] = points[i];
        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
      }

      for (let i = 100; i < points.length; i++) {
        const [x, y] = points[i];
        const [cx, cy] = toCanvas(x, y, minX, maxX, minY, maxY);
        ctx.fillStyle = i % 2 === 0 ? "lime" : "red";
        ctx.fillRect(cx, cy, 1, 1);
      }

      const greenPoints = points.filter((_, i) => i % 2 === 0 && i >= 100);
      const redPoints = points.filter((_, i) => i % 2 !== 0 && i >= 100);
      const [step1, step2, step3, step4, step5, status] = pointCloudCollisionDetection(greenPoints, redPoints);
      stepsDiv.innerHTML = `
        <p>${step1.replace(/\n/g, '<br>')}</p>
        <p>${step2.replace(/\n/g, '<br>')}</p>
        <p>${step3.replace(/\n/g, '<br>')}</p>
        <p>${step4.replace(/\n/g, '<br>')}</p>
        <p>${step5.replace(/\n/g, '<br>')}</p>
        <p><strong>Kết luận (k = ${k.toFixed(2)}): ${status}</strong></p>
      `;
    }

    draw();

    function animate() {
      if (points.length < maxPoints) {
        draw();
      }
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>